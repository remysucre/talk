\documentclass{beamer}

\usepackage{listings}
\lstset{
  columns=flexible,
  mathescape=true,
  keepspaces=true,
  showstringspaces=false,
  stringstyle=\slshape\color{green!40!black},
  basicstyle=\ttfamily\small,
  language=SQL,
  morekeywords={*, self},
  commentstyle=\slshape\color{black!60},
  tabsize=2,
}

\usetheme{metropolis}           % Use metropolis theme

\title{Optimizing Modern Data Processing Systems with Automated Reasoning}
\date{\today}
\author{Remy Wang}
\institute{University of Washington}
\begin{document}
  \maketitle

  \begin{frame}{Overview}
    \tableofcontents
  \end{frame}

  \section{Modern Data Processing}

  \begin{frame}{Modern Data Processing: Queries}
    Betweenness centrality of a graph $E$:
    \begin{align*}
      C(s, v) = \sum_{t: E(v, t) \wedge D(s, t)=D(s, v+1)} 
      \frac{\sigma(s, v)}{\sigma(s, t)}(1+ C(s, t))
    \end{align*}
    where $D$ is the distance, $\sigma$ is the \# of shortest paths. \pause
    \begin{itemize}
      \item Non-relational data \pause
      \item Aggregation \& interpreted functions \pause
      \item Recursive \pause
     \end{itemize}
    \textbf{Expressiveness} not well-supported by traditional optimizers:
    \[\#[R \times S] \Rightarrow \#[R] \cdot \#[S]\]
  \end{frame}

  \begin{frame}{Modern Data Processing: Data}
    \begin{columns}
      \begin{column}{{0.5\textwidth}}
        \includegraphics[width=\linewidth]{datasphere.png}
      \end{column}
      \begin{column}{{0.5\textwidth}}
        \includegraphics[width=\linewidth]{fb.png}
      \end{column}
    \end{columns}
    \begin{itemize}
      \item Data is increasing in \textbf{volume} \& \textbf{velocity} \pause
      \item The optimizer needs to produce faster plans in shorter time
    \end{itemize}
  \end{frame}

  \begin{frame}{Modern Data Processing: Systems}
    \begin{figure}
    \includegraphics[width=\linewidth]{systems.png}
    \end{figure}
    \begin{itemize}
      \item Every data processing system needs an optimizer!
      \item Simplifying optimizers can save a lot of time for everyone.
    \end{itemize}
  \end{frame}

  \begin{frame}{My Theses}
    \begin{itemize}
      \item Core components and techniques from \textbf{automated reasoning}
      can make query optimizers simpler, more efficient,
      and more effective. \pause
      \item The \textbf{functional representation} of data can enable query 
      optimizers to effectively leverage automated reasoning tools.
    \end{itemize}
  \end{frame}

  \section{Background: Query Optimization and Reasoning}
  \begin{frame}{Query Optimization}
    \begin{figure}
      \includegraphics[width=0.7\linewidth]{opt.pdf}
    \end{figure}
    Given an input query and constraints on the data, 
    output an equivalent query that is more efficient. \pause \\
    This is a \textbf{synthesis problem}: given a specification,
    output a program that satisfies the spec.
  \end{frame}

  \begin{frame}{Query Optimization}
    A related problem: given constraints ($\Sigma$) on the data ($I$), 
    check if two queries ($\psi, \phi$) are equivalent.
    \[\forall I . \Sigma(I) \implies (\psi(I) = \phi(I)) \] \pause
    This is a \textbf{verification problem}:
    given a specification, check that a program meets the specification.
  \end{frame}

  \begin{frame}{Automated Reasoning}
    Both verification problems and synthesis problems are studied 
    extensively in automated reasoning.
  \end{frame}

  \begin{frame}{Automated Reasoning for Data Processing}
    \textbf{The Chase} is an algorithm that has wide applications 
    in data management. It has the property:
    \begin{alertblock}{The Chase preserves query equivalence}
      Chasing a query $Q$ with a set of integrity constraints $\Sigma$
      results in a query $Q'$ s.t.~$\Sigma \models Q'\equiv Q$.
    \end{alertblock}
  \end{frame}

  \begin{frame}{Automated Reasoning for Data Processing}
    \textbf{Chase \& Backchase}: Given $Q$, find the smallest~\footnote{
      Refer to CITE for a formal definition of ``small''.
    }
    query $Q'$ s.t.~$Q'\equiv Q$.
    \begin{figure}
      \includegraphics[width=0.3\linewidth]{backchase.pdf}
    \end{figure}
    First chase the input into a {\em universal} plan $\hat Q$, \pause 
    then check if any subplan $Q'$ of $\hat Q$ is equiv.~to $Q$,
    by chasing $Q'$.
  \end{frame}

  \begin{frame}{Automated Reasoning for Data Processing}
    \textbf{Tree Automata} can capture certain class of
    relational queries, by coding tree-like data with trees.
    \begin{figure}
      \colorbox{white}{
      \includegraphics[width=0.3\linewidth]{tree1.pdf}
      \hspace{1cm}
      \includegraphics[width=0.3\linewidth]{tree2.pdf}}
    \end{figure}
    \pause
    Emptiness of tree automata is \textbf{decidable}! \\
    Check query containment: 
    $Q_1 \subseteq Q_2 \rightarrow A_{Q_1 \wedge \neg Q_2} = \emptyset$
  \end{frame}

  \section{The Functional Representation of Data}
  \section{Building Optimizers that Reason}
  \section{Proposal: Improving Optimizers with Reasoning}
\end{document}
